// MatsSocket

import java.nio.charset.StandardCharsets
import java.time.LocalDateTime
import org.gradle.internal.jvm.Jvm

plugins {
    id 'com.github.node-gradle.node' version '7.1.0' // For Node.js download & tasks
    id 'java-library'
    id "com.vanniktech.maven.publish" version "0.34.0" // Publish to Maven Central, over Portal Publisher API
}

// Specify Gradle version, run update by './gradlew wrapper'
wrapper {
    gradleVersion = "8.14.3"
    // Use "-all"-version of distribution, since IntelliJ works better then..
    setDistributionType(Wrapper.DistributionType.ALL)
}

// Version, common config for all projects
allprojects {
    group = 'io.mats3.matssocket'
    version = '0.19.1-2025-09-30'
    // NOTE!! Versions are spread around 6 places:
    // * Here, in root build.gradle
    // * matssocket-server-impl/src/main/java/io/mats3/matssocket/impl/DefaultMatsSocketServer.java
    // * matssocket-client-javascript/client/package.json
    // * matssocket-client-javascript/client/lib/MatsSocket.js
    // * matssocket-client-dart/pubspec.yaml
    // * matssocket-client-dart/lib/src/MatsSocket.dart

    layout.buildDirectory.set(file('build-gradle'))
}

// Versions for all libraries used throughout the subprojects
ext {
    // MatsSocketServer API dependencies
    matsVersion = '1.0.0+2025-05-17'
    // MatsSocketServer Implementation dependencies
    javaxWebsocketsVersion = '1.0'
    jacksonVersion = '2.17.2'
    slf4jVersion = '2.0.16'

    // optional for DB setup/migration
    flywayVersion = '9.7.0'

    // For testing
    logbackVersion = '1.5.8'
    h2Version = '2.3.232'
    jettyVersion = '9.4.56.v20240826'

    // .. full path for the JMS lib
    jmsApiDependency = 'jakarta.jms:jakarta.jms-api:2.0.3'

    // Build tools: Dart SDK and Node.js
    dartSdkVersion = '3.9.3'
    nodeVersion = '24.7.0' // Current as of 2025-09-08, will become LTS.
}

// :: Find which Java version to use for the toolchain.
int javaVersion = 11;
if (project.properties.containsKey('mats.build.java_version')) {
    javaVersion = Integer.parseInt((String) project.properties['mats.build.java_version'])
    println "Specified Java version for toolchain, using Java version: $javaVersion"
}

// Common config for the two Java subprojects
configure([project('matssocket-server-api'), project('matssocket-server-impl')]) {
    apply plugin: 'java-library'
    apply plugin: "com.vanniktech.maven.publish"

    repositories { mavenCentral() }

    java {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11

        toolchain {
            languageVersion.set(JavaLanguageVersion.of(javaVersion))
        }
    }

    compileJava {
        options.encoding = 'UTF-8'
        options.deprecation = true
        options.incremental = true
        options.compilerArgs += ['-Werror', '-Xlint:all', '-Xlint:-serial']
    }

    javadoc {
        // without the -quiet option, the build fails due to errors&warns
        options.addStringOption('Xdoclint:none', '-quiet')
    }

    jar {
        manifest {
            attributes 'Implementation-Title': 'MatsSocket',
                    'Implementation-Version': archiveVersion
        }
    }

    test {
        /*
         * All tests employ MatsTestBroker to get hold of a JMS ConnectionFactory to use for its MatsFactory creation.
         * This per default starts an in-vm ActiveMQ broker, and connects an ActiveMQConnectionFactory to this.
         * However, via system properties, you may choose which client to use (activemq, artemis or rabbitmq - and
         * you may also specify the class name of a MatsTestBroker implementation).
         * For ActiveMQ and Artemis, it supports in-vm creation of the broker (server) - which is the default.
         *
         * Run all tests with in-vm ActiveMQ brokers (ActiveMQ is default, in-vm is default)
         * ./gradlew clean test
         *
         * Run all tests with in-vm Artemis MQ brokers (Apache ActiveMQ Artemis, formerly JBoss HornetQ,
         * and what Red Hat AMQ is based upon):
         * ./gradlew -Pmats.test.broker=artemis clean test
         *
         * Run all tests against an external ActiveMQ MQ broker on localhost (ActiveMQ is default).
         * ./gradlew -Pmats.test.brokerurl=localhost clean test
         *
         * Run all tests against an external Artemis MQ broker on localhost:
         * ./gradlew -Pmats.test.broker=artemis -Pmats.test.brokerurl=localhost clean test
         */
        // NOTICE: Currently no Java tests. These properties are also forwarded to the MatsSocketTestServer exec below.
        systemProperties project.properties.subMap(["mats.test.brokerurl", "mats.test.broker"])

        // Move over the CI environment variable, so that we can increase timings of tests if on CI environment.
        // (Check MatsTestLatch.WAIT_MILLIS_FOR_NON_OCCURENCE)
        systemProperties System.getenv().subMap(["CI"])

        testLogging {
            exceptionFormat = 'full'
        }
    }

    mavenPublishing { // 'publishToMavenCentral' task.
        publishToMavenCentral()
        signAllPublications()
        coordinates(group.toString(), name, version.toString())

        pom {
            name = 'MatsSockets'
            description = 'WebSocket-based server and client libs for asynchronous, bidirectional interaction with Mats3 from end-user clients'
            url = 'https://github.com/centiservice/matssocket'
             licenses {
                license {
                    name = 'Apache License, Version 2.0'
                    url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                }
            }
            developers {
                developer {
                    id = 'stolsvik'
                    name = 'Endre St√∏lsvik'
                    email = 'endre@stolsvik.com'
                }
            }
            scm {
                connection = 'scm:git:https://github.com/centiservice/matssocket.git'
                developerConnection = 'scm:git:ssh://github.com:centiservice/matssocket.git'
                url = 'https://github.com/centiservice/matssocket'
            }
        }
    }

    // Clean out 'out' directory that may be created by IntelliJ.
    tasks.register('distclean', Delete) {
        dependsOn clean
        delete "$projectDir/out/"
    }

    // Define dependency report task that the Java subprojects gets. Invoke with "./gradlew allDeps | less"
    tasks.register('allDeps', DependencyReportTask) {}
}

// For "all JavaDoc" task, sweeping together all sources to make a complete set of JavaDoc in one go.
// - Adapted from https://coderwall.com/p/evtdbw/aggregate-javadoc-in-multiproject-gradle-builds
apply plugin: 'java'
tasks.register('alljavadoc', Javadoc) {
    def relevantProjects = subprojects.findAll { it.name != 'mats-api-test' }
    source relevantProjects.collect { it.sourceSets.main.allJava }
    classpath = files(relevantProjects.collect { it.sourceSets.main.compileClasspath })
    destinationDir = file("${layout.buildDirectory}/docs/javadoc")
    options.addStringOption('Xdoclint:none', '-quiet')
    options.addStringOption('--frames')
}
// .. ensure 'alljavadoc' is run together with './gradlew clean javadoc', thus building 'all' + submodules.
javadoc.dependsOn alljavadoc


// ------------------------------------------------------------
// -- Shared Parameters needed between tasks and subprojects

// "Shared build services allow tasks to share state or resources." Yes.
abstract class SharedParametersService implements BuildService<StaticParams> {
    interface StaticParams extends BuildServiceParameters {
        Property<String> getMatsSocketTestServerClassName();
    }
    @Inject
    abstract ObjectFactory getObjects()
    /* mutable data that tasks can read/write at execution time */
    private final RegularFileProperty logFile = getObjects().fileProperty()
    private final ListProperty<String> matsSocketUris = getObjects().listProperty(String.class)

    ListProperty<String> getMatsSocketUris() { matsSocketUris }

    RegularFileProperty getLogFile() { logFile }
}
def sharedParamsService = gradle.sharedServices.registerIfAbsent('sharedParamsService', SharedParametersService) { spec ->
    spec.parameters.matsSocketTestServerClassName.set("io.mats3.matssocket.MatsSocketTestServer")
}
// Store it for subprojects.
ext.sharedParamsService = sharedParamsService


// ------------------------------------------------------------------------------------------------
// Task to start a MatsSocketTestServer. We will monitor the log until we get the expected number
// of ws urls, that other tasks can then depend on
tasks.register('startMatsSocketTestServer_internal') {
    dependsOn configurations.testRuntimeClasspath, 'matssocket-server-impl:compileTestJava', 'matssocket-server-impl:processTestResources'
    usesService(sharedParamsService)

    // Precompute values at configuration time to avoid accessing Task.project during execution
    def matsSystemProps = ['mats.test.brokerurl', 'mats.test.broker']
            .collect { key ->
                def v = providers.gradleProperty(key).orNull
                v ? "-D${key}=${v}" : null
            }
            .findAll { it != null }

    def serverClasspath = files(
            project(':matssocket-server-api').sourceSets.test.runtimeClasspath,
            project(':matssocket-server-impl').sourceSets.test.runtimeClasspath
    )

    File buildDirectory = layout.buildDirectory.get().asFile

    doLast {
        int numberOfServers = 3
        String matsSocketTestServerClassname = sharedParamsService.get().parameters.matsSocketTestServerClassName.get()

        logger.info("Starting MatsSocketTestServer - class $matsSocketTestServerClassname, numberOfServers $numberOfServers")

        // :: Create cmd-line for MatsSocketTestServer Java-process to execute
        def javaExe = Jvm.current().javaExecutable.absolutePath

        println "MatsSocketTestServer: Using Java executable: $javaExe, class: $matsSocketTestServerClassname, numberOfServers: $numberOfServers"

        List<String> cmd = [javaExe]
        // Add the MatsTestBroker -P properties as -D properties to the JVM, if set (precomputed above)
        cmd.addAll(matsSystemProps)
        // Add classpath, from test's runtimeClasspath for both server-api and server-impl projects (precomputed above)
        cmd << "-classpath" << serverClasspath.asPath
        // The classname to execute, with argument which is the number of servers to start
        cmd << matsSocketTestServerClassname << numberOfServers.toString()

        // Execute!
        // println "MatsSocketTestServer: Executing: ${cmd.join(" ")}" // Verbose due to classpath
        Process server = cmd.execute()

        // Keep a log file of the server output

        def logFile = new File("${buildDirectory}/logs/matsSocketServer-${LocalDateTime.now().withNano(0).toString().replace(':', '.')}.log")
        println "MatsSocketTestServer: Logging to ${logFile.path}"
        logFile.parentFile.mkdirs();

        def matsSocketUris = []

        // :: Find the WebSocket URLs from the output, via magic hook-line in log output
        Reader reader = new InputStreamReader(server.inputStream, StandardCharsets.UTF_8)
        logFile.withWriterAppend { out ->
            String line;
            while (matsSocketUris.size < numberOfServers && (line = reader.readLine()) != null) {
                out.writeLine(line)
                logger.info("TestServer: $line")
                if (line.contains('HOOK_FOR_GRADLE_WEBSOCKET_URL')) {
                    int urlStart = line.indexOf("#[")
                    int urlEnd = line.indexOf("]#")
                    if (urlStart > -1 && urlEnd > urlStart) {
                        String url = line.substring(urlStart + 2, urlEnd)
                        matsSocketUris.add(url)
                        logger.info("!! Registering WS URL: $url");
                    }
                }
            }
        }
        if (matsSocketUris.isEmpty()) {
            server.errorStream.eachLine { logger.error(it) }
            logger.error("Failed to execute: [${cmd.join(" ")}]")
            throw new GradleException("Failed to start $matsSocketTestServerClassname, check log above for command.")
        }
        println "MatsSocketTestServer: Started, WebSocket URLs: ${matsSocketUris}"
        logger.info "$matsSocketTestServerClassname started, WebSocket URLs: ${matsSocketUris}"

        sharedParamsService.get().logFile.set(logFile)
        sharedParamsService.get().matsSocketUris.set(matsSocketUris)

        // Fork a new thread to just keep reading and logging the MatsSocketTestServer
        // Notice: It will exit once the process exits, as the reader will then be done.
        new Thread({
            logFile.withWriterAppend { out ->
                reader.eachLine { line ->
                    out.writeLine(line)
                }
            }
            println "MatsSocketTestServer: std.out -> logfile thread exiting, logfile: ${logFile.path}"
        }, "MatsSocketTestServer-logprinter").start()
    }
}

// Task for starting the MatsSocketTestServer and keeping it alive - so that it can be accessed and used from command
// line tests etc.
tasks.register('matsSocketTestServer') {
    usesService(sharedParamsService)
    dependsOn 'startMatsSocketTestServer_internal'
    doLast {
        File logFile = sharedParamsService.get().logFile.get().asFile
        String matsSocketTestServerClassname = sharedParamsService.get().parameters.matsSocketTestServerClassName.get()
        List<String> matsSocketUris = sharedParamsService.get().matsSocketUris.get()
        println "LogFile: $logFile"
        println ''
        println "MatsSocketTestServer is running!  (class: ${matsSocketTestServerClassname})"
        println ''
        println "HTTP URLs:       " + matsSocketUris.collect { it.replace("ws://", "http://").replace("/matssocket", "") }
        println "MatsSocket URLs: ${matsSocketUris}"
        println "Logfile:         ${logFile.path}"
        println ''
        println '  #####################################################################'
        println '  ### PRESS [Enter] IN THIS TERMINAL WINDOW TO TERMINATE THE SERVER ###'
        println '  #####################################################################'
        println ''
        try {
            System.in.withReader { it.readLine() }
        } catch (ignore) {
            // no-op
        }
        println 'Stopping MatsSocketTestServer...'
    }
}

// Task to start a MatsSocketTestServer for integration tests in gradle, that will be stopped when the build is done.
tasks.register('startMatsSocketTestServer') {
    dependsOn 'startMatsSocketTestServer_internal'
}

// Stop the MatsSocketTestServer, this is done by inspecting the wsUrls field on the start task,
// and creating a url to the shutdown page based on the first websocket url. The shutdown page is
// a servlet that will do System.exit(0) to shutdown the server.
tasks.register('stopMatsSocketTestServer') {
    usesService(sharedParamsService)
    dependsOn startMatsSocketTestServer
    doLast {
        List<String> matsSocketUris = sharedParamsService.get().matsSocketUris.get()
        String shutdownUrl = matsSocketUris[0]
                .replace("ws://", "http://")
                .replace("/matssocket", "/shutdown");
        logger.info("Shutting down MatsSocketTestServer by invoking '$shutdownUrl")
        String response = new URL(shutdownUrl).text
        logger.info("Response: [${response.trim()}]")
        println "MatsSocketTestServer shut down"
        Thread.sleep(500)
    }
}

// Make sure that the startMatsSocketTestServer is finalized and shut down.
startMatsSocketTestServer.finalizedBy(stopMatsSocketTestServer)
matsSocketTestServer.finalizedBy(stopMatsSocketTestServer)

// Clean out random directories that I've seen pop up..
tasks.register('distclean', Delete) {
    dependsOn clean
    delete "$projectDir/build/"
    delete "$projectDir/build-gradle/"
    delete "$projectDir/.gradle/nodejs/"
    delete "$projectDir/.gradle/yarn/"
}

// ------------------------------------------------
// -- Simple tools

tasks.register('systemInformation') {
    dependsOn 'versions'
    doLast {
        println "\n** Java properties [System.getProperties()], sorted:\n"
        System.properties.sort().each { k, v ->
            println("$k = $v")
        }
        println "\n** Environment [System.getenv()], sorted:\n"
        System.env.sort().each { k, v ->
            println("$k = $v")
        }
    }
}

tasks.register('versions') {
    def gradleVersion = gradle.gradleVersion
    doLast {
        println "** Gradle Version: " + gradleVersion
        println "** Java Version:   " + System.getProperty("java.version")
        println "** Groovy Version: " + GroovySystem.getVersion()
    }
}

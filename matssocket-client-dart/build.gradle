// MatsSocket-Client-Dart

// Hacky way to get Node.js here for "platform=node" tests
apply from: '../matssocket-client-javascript/node.gradle' // For the "node" extension

repositories {
    // Create a custom ivy repository that represents the dart sdk download, so that we
    // can download the SDK using gradles download mechanisms and cache.
    ivy {
        url = "https://storage.googleapis.com/dart-archive/channels/stable/release/"
        patternLayout {
            artifact "[revision]/sdk/[artifact]-[classifier]-release.[ext]"
        }
        metadataSources {
            artifact()
        }
    }
}

ext {
    // dartSdkVersion is set in root build.gradle (where also node is defined)
    dartDownloadTemp = file("$projectDir/dartsdk_download-temp")
    dartDownload = file("$projectDir/dartsdk_download")
    dartSdkPath = file("$dartDownload/dart-sdk")
}

configurations {
    dartSdk
}

// :: Find where Dart can be downloaded from, based on current OS (win, mac, linux)
dependencies {
    def currentOs = org.gradle.internal.os.OperatingSystem.current()
    def platformClassifier =
            currentOs.isWindows() ? "windows-x64" :
            currentOs.isMacOsX() ? "macos-x64" :
            currentOs.isLinux() ? "linux-x64" : null
    if (platformClassifier == null) {
        throw new GradleException("Unsupported OS for Dart SDK: ${currentOs}")
    }
    dartSdk "com.google.dart:dartsdk:${dartSdkVersion}:${platformClassifier}@zip"
}

tasks.register('build') {
    dependsOn archiveLib, test, dartDoc
}

tasks.register('download') {
    dependsOn nodeBinDir, dartBinPath
}

tasks.register('downloadAll') {
    dependsOn download, dartPubGet
}

abstract class UnzipHelper {
    @Inject
    protected abstract FileSystemOperations getFs()

    @Inject
    protected abstract ArchiveOperations getArchives()

    /** Extracts {@code zipFile} into {@code targetDir} preserving permissions. */
    void unzip(File zipFile, File targetDir) {
        getFs().copy { spec ->
            spec.from(getArchives().zipTree(zipFile))
            spec.into(targetDir)
        }
    }
}

// ===============================
// Dart tasks

tasks.register('installDart') {
    // ---- Declare inputs ----
    inputs.files(configurations.dartSdk)        // The Dart SDK zip file

    // ---- Declare outputs ----
    outputs.dir(dartDownload)                   // unpacked SDK

    File _dartDownloadTemp_ = project.dartDownloadTemp
    File _dartDownload_ = project.dartDownload

    def _dartSdkFile_ = configurations.dartSdk.singleFile;
    def unzipper = objects.newInstance(UnzipHelper)

    doLast {
        println "Pre-cleaning Dart temp dir '$_dartDownloadTemp_' and target dir '$_dartDownload_'"

        _dartDownloadTemp_.deleteDir()
        _dartDownload_.deleteDir()
        // Fetch the Dart SDK from "custom ivy repo" set up above
        println "Unzipping Dart SDK to temp dir '$_dartDownloadTemp_'"
        unzipper.unzip(_dartSdkFile_, _dartDownloadTemp_)

        // Move it into place - avoids problem if IntelliJ is set up to use the Dart SDK here ("Text file busy")
        // Note: If on Windows, you'll probably have to find another SDK location for IntelliJ, as it locks the files.
        println "Renaming Dart SDK download to '$_dartDownload_'"
        _dartDownloadTemp_.renameTo(_dartDownload_)
    }
}

abstract class DartExec extends DefaultTask {
    @Inject
    abstract ExecOperations getExecOperations()

    private File dartSdkPath   = project.ext.dartSdkPath
    private File projectDir   = project.projectDir

    void dartExecClosure(Closure body) {
        File dartSdkPath = this.dartSdkPath
        File projectDir = this.projectDir
        getExecOperations().exec { spec ->
            spec.executable org.gradle.internal.os.OperatingSystem.current().getExecutableName("${dartSdkPath}/bin/dart")
            spec.environment 'PATH', "${dartSdkPath}/bin${File.pathSeparator}${System.getenv('PATH')}"
            spec.workingDir projectDir
            body.delegate = spec
            body.resolveStrategy = Closure.DELEGATE_FIRST
            body()
        }
    }
    void dartExec(Object... cmd) {
        dartExecClosure {
            args cmd
        }
    }
}

tasks.register('dartPubGet', DartExec) {
    dependsOn 'installDart'

    // ---- Declare inputs ----
    inputs.files(configurations.dartSdk)        // The Dart SDK zip file
    inputs.file("pubspec.yaml")                 // Specification of dependencies

    // ---- Declare outputs ----
    outputs.dir(dartDownload)                   // unpacked SDK
    outputs.dir("${projectDir}/.dart_tool")     // dart pub get stuff
    outputs.file("pubspec.lock")                // the resulting pubspec lock file

    doLast {
        // Update dart dependencies by executing 'pub get'
        println "Executing 'dart pub get' to resolve and fetch dependencies."
        dartExec 'pub', 'get'
    }
}

tasks.register('dartBinPath') {
    dependsOn installDart
    String dartSdkPath = dartSdkPath
    doLast {
        println "=== Dart executable: ${org.gradle.internal.os.OperatingSystem.current().getExecutableName("$dartSdkPath/bin/dart")}"
        println "=== Dart bin dir   : $dartSdkPath/bin/"
        println "    Unix:     export PATH=$dartSdkPath/bin/:\$PATH"
        println "    Windows:  set PATH=$dartSdkPath/bin/;%PATH%"
    }
}

// :: 'dart doc'
tasks.register('dartDoc', DartExec) {
    dependsOn dartPubGet

    // Inputs: source files and pubspec that affect docs
    inputs.dir("$projectDir/lib")
    inputs.file("$projectDir/pubspec.yaml")
    inputs.file("$projectDir/README.md").optional(true)
    inputs.file("$projectDir/CHANGELOG.md").optional(true)
    inputs.file("$projectDir/analysis_options.yaml").optional(true)

    // Outputs: doc/api directory
    outputs.dir("$projectDir/doc")

    File _docDir_ = file("$projectDir/doc");

    // :: Clean before create
    doFirst {
        _docDir_.deleteDir()
    }
    doLast {
        dartExec 'doc'
    }
}


// :: 'dart outdated'
tasks.register('dartOutdated', DartExec) {
    dependsOn dartPubGet
    doLast {
        dartExec 'pub', 'outdated'
    }
}

// :: 'dart upgrade'
tasks.register('dartUpgradeUpdate', DartExec) {
    dependsOn dartPubGet
    doLast {
        dartExec 'pub', 'upgrade', '--major-versions'
    }
}

// :: 'dart version'
tasks.register('dartVersion', DartExec) {
    dependsOn dartPubGet
    doLast {
        dartExec '--version'
    }
}
tasks.register('versions') { dependsOn dartVersion }

// :: 'dart pub global run pana' - to check whether we get full score on pub.dev
tasks.register('dartPana', DartExec) {
    dependsOn dartPubGet
    doLast {
        dartExec 'pub', 'global', 'run', 'pana'
    }
}

// 'dart publish --dry-run' // == NOTE! DO A './gradlew -PchromePath=<path> testDart' first!
tasks.register('dartPublishDryRun', DartExec) {
    dependsOn dartPubGet, testVmKernel, dartDoc
    doLast {
        dartExec 'pub', 'publish', '--dry-run'
    }
}

// 'dart publish' // == NOTE! DO A './gradlew -PchromePath=<path> testDart' first!
// Check versions in pubspec.yaml and MatsSocket.dart
tasks.register('dartPublish', DartExec) {
    dependsOn dartPubGet, testVmKernel, dartDoc
    doLast {
        dartExec 'pub', 'publish'
    }
}

// Package up the Dart library
tasks.register('archiveLib', Zip) {
    from "$projectDir/lib"
    into "mats_socket-${project.version}-dart"
    def destinationDir = layout.buildDirectory.dir("dist").get().asFile
    def archiveName = "matssocket-${project.version}-dart.zip"
    destinationDirectory = destinationDir
    archiveFileName = archiveName
    doLast {
        println("##### Dart Client zip: " + destinationDir + "/" + archiveName)
    }
}

// ===============================
// Comprehensive test setup!

// :: This is an experiment of running dart from "command line". Setting path for node, and then invoking dart.
tasks.register('experimentWithExecutingDartAndNode', Exec) {
    dependsOn 'dartPubGet', ':startMatsSocketTestServer'
    String nodeBinDir = "${node.resolvedNodeDir.get()}${org.gradle.internal.os.OperatingSystem.current().isWindows() ? '\\' : '/bin'}"
    String dartSdkPath = dartSdkPath
    // Globs like "test/*.dart' doesn't expand - that's a shell's job. So we need to do it ourselves.
    // A trick is to actually run 'sh -c <command>' instead, but that's not portable.
    def testFiles = file("$projectDir/test")
            .listFiles().findAll { it.name.endsWith(".dart") }.collect { "test/${it.name}" }
    doFirst {
        println "Node's bin dir: $nodeBinDir"
        environment 'PATH', "${nodeBinDir}${File.pathSeparator}$dartSdkPath/bin${File.pathSeparator}${System.getenv('PATH')}"
        // For some frikkin' reason, the above-set PATH will not affect the lookup of the executable (i.e. just "dart"),
        // so we need set executable with absolute path.
        executable org.gradle.internal.os.OperatingSystem.current().getExecutableName("$dartSdkPath/bin/dart")
        args = ['test', '-p', 'node', '-c', 'dart2js', '--reporter=expanded'] + testFiles
    }
}

// Helper to register a Dart test task with platform and compiler variants.
def registerDartTestTask = { String name, String platform, String compiler ->
    tasks.register(name, DartExec) {
        usesService(rootProject.sharedParamsService)
        dependsOn 'dartPubGet', ':startMatsSocketTestServer'
        if (platform == 'node') {
            dependsOn 'nodeSetup'
        }

        Provider<String> chromePath = providers.gradleProperty('chromePath')
        Provider<String> dartLogLevel = providers.gradleProperty('dartLogLevel')
        List<GString> testFiles = file("$projectDir/test")
                .listFiles().findAll { it.name.endsWith(".dart") }.collect { "test/${it.name}" }
        def sharedParamsService =  rootProject.sharedParamsService;
        String nodeBinDir = "${node.resolvedNodeDir.get()}${org.gradle.internal.os.OperatingSystem.current().isWindows() ? '\\' : '/bin'}"

        doLast {
            dartExecClosure {
                // Must resolve after Servers are running!
                def matsSocketUrls = sharedParamsService.get().matsSocketUris.get().join('$')
                environment("MATS_SOCKET_URLS", matsSocketUrls)

                var logLevel
                if (dartLogLevel.isPresent()) {
                    logLevel = dartLogLevel.get()
                } else {
                    // Checking which log level is enabled to pass on to the tests, so that they log if needed.
                    if (logger.isEnabled(LogLevel.DEBUG)) {
                        logLevel = "ALL"
                    } else if (logger.isEnabled(LogLevel.INFO)) {
                        logLevel = "INFO"
                    } else {
                        logLevel = "SEVERE"
                    }
                }
                environment("LOG_LEVEL", logLevel)

                // We want to set LOG_LEVEL and MATS_SOCKET_URLS using compile constants, using 'define'.
                // BUT: The define stuff doesn't work as of 2025-09-21: https://github.com/dart-lang/sdk/issues/51791
                // Had it worked, it should be picked up in "test/lib/env.dart"
                args = ["-DLOG_LEVEL=${logLevel}", "-DMATS_SOCKET_URLS=\"${matsSocketUrls}\"",
                        'test', '-p', platform, '-c', compiler, '--reporter=expanded', '--concurrency', '1'] + testFiles
                if (platform == 'chrome' && chromePath.isPresent()) {
                    println "Setting env CHROME_EXECUTABLE=${chromePath.get()}"
                    environment("CHROME_EXECUTABLE", chromePath.get())
                }
                if (platform == 'node') {
                    println "Adding Node to PATH: ${nodeBinDir}"
                    environment 'PATH', "${nodeBinDir}${File.pathSeparator}${System.getenv('PATH')}"
                }
                println "Executing 'dart ${args.join(" ")}' to run tests."
            }
        }
    }
}

// :: Define the various test tasks with their platform/compiler variants.
registerDartTestTask('testVmKernel', 'vm', 'kernel')
registerDartTestTask('testVmSource', 'vm', 'source')
registerDartTestTask('testVmExe', 'vm', 'exe')
registerDartTestTask('testNodeJs', 'node', 'dart2js')
registerDartTestTask('testNodeWasm', 'node', 'dart2wasm')
registerDartTestTask('testWebJs', 'chrome', 'dart2js')     // Might want to set -PchromePath=
registerDartTestTask('testWebWasm', 'chrome', 'dart2wasm') // Might want to set -PchromePath=

// .. Subsets
tasks.register('testVm') { dependsOn 'testVmKernel', 'testVmSource', 'testVmExe' }
tasks.register('testNode') { dependsOn 'testNodeJs', 'testNodeWasm'}
tasks.register('testWeb') { dependsOn 'testWebJs', 'testWebWasm' }  // Might want to set -PchromePath=

// .. All tests
tasks.register('testDart') { dependsOn 'testVm', 'testNode', 'testWeb' }   // Might want to set -PchromePath=

// .. Make 'test' be both VM and Node - but handle bug with Node+WASM on Windows.
// ?: Are we running on Windows? (GHA)
if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
    // -> Yes, Windows, special handling. Avoid the testNodeWasm, as it fails due to bad path handling,
    // e.g. '/runner' becomes '<linefeed>unner', and fails.
    tasks.register('test') { dependsOn 'testVm', 'testNodeJs' }
}
else {
    // -> No, not Windows, so include all testVm and testNode tasks.
    tasks.register('test') { dependsOn 'testVm', 'testNodeJs', 'testNodeWasm' }
}

// We need to ensure that dart tests are run before stopping the test MatsSocketServer.
rootProject.stopMatsSocketTestServer.mustRunAfter(testWebJs, testWebWasm, testVmExe, testVmSource, testVmKernel,
        testNodeJs, testNodeWasm, test, testDart, experimentWithExecutingDartAndNode)

// ===== Clean tasks

tasks.register('clean', Delete) {
    delete layout.buildDirectory
    delete "$projectDir/doc"
}

tasks.register('distclean', Delete) {
    dependsOn clean, distcleanNode
    delete "$dartDownload"
    delete "$dartDownloadTemp"
    delete "$projectDir/.dart_tool"
    delete "$projectDir/pubspec.lock"
    delete "$projectDir/package-lock.json" // If npmUpdate is run in this submodule
}

// MatsSocket-Client-Dart


// Hacky way to get Dart here for "platform=dart" tests
apply from: '../matssocket-client-javascript/node.gradle' // For the "node" extension

repositories {
    // Create a custom ivy repository that represents the dart sdk download, so that we
    // can download the SDK using gradles download mechanisms and cache.
    ivy {
        url = "https://storage.googleapis.com/dart-archive/channels/stable/release/"
        patternLayout {
            artifact "[revision]/sdk/[artifact]-[classifier]-release.[ext]"
        }
        metadataSources {
            artifact()
        }
    }
}

ext {
    dartSdkVersion = "$dartSdkVersion"
    dartDownloadTemp = file("$projectDir/dartsdk_download-temp")
    dartDownload = file("$projectDir/dartsdk_download")
    dartSdkPath = file("$dartDownload/dart-sdk")
}

configurations {
    dartSdk
}

def currentOs = org.gradle.internal.os.OperatingSystem.current()
dependencies {
    def platformClassifier =
            currentOs.isWindows() ? "windows-x64" :
            currentOs.isMacOsX() ? "macos-x64" :
            currentOs.isLinux() ? "linux-x64" : null
    if (platformClassifier == null) {
        throw new GradleException("Unsupported OS for Dart SDK: ${currentOs}")
    }
    dartSdk "com.google.dart:dartsdk:${dartSdkVersion}:${platformClassifier}@zip"
}


def nodeOut = new ByteArrayOutputStream()
tasks.register('nodeBinDir', NodeTask) {
    script = file('README.md') // node-gradle requires the script property, so just point to something harmless.
    options = ['-p', "require('path').dirname(process.execPath)"]
    // Capture stdout so we can use it later in the build.
    execOverrides {
        standardOutput = nodeOut
    }
    doLast {
        def binDir = nodeOut.toString().trim()
        println "Node bin dir: ${binDir}"
        // Stash it for other tasks to use
        project.ext.set('NODE_BIN_DIR', binDir);
    }
}

tasks.register('dartTestNode', Exec) {
    dependsOn nodeBinDir
    doFirst {
        println "NODE_BIN_DIR (from project.ext): ${project.ext.NODE_BIN_DIR}"
        environment 'PATH', "${NODE_BIN_DIR}${File.pathSeparator}$dartSdkPath/bin${File.pathSeparator}${System.getenv('PATH')}"
        commandLine 'bash', '-c', 'dart test -p node -c dart2js --reporter=expanded test/*.dart'
    }
}


tasks.register('build') {
    dependsOn archiveLib, test
}

// Small helper to run the Dart executable with common configuration.
def dartExec(Closure body) {
    services.get(ExecOperations).exec { ExecSpec spec ->
        def os = org.gradle.internal.os.OperatingSystem.current()
        spec.executable os.getExecutableName("$dartSdkPath/bin/dart")
        spec.workingDir projectDir
        body.delegate = spec
        body.resolveStrategy = Closure.DELEGATE_FIRST
        body()
    }
}

def dartExec(Object... cmd) {
    dartExec {
        args cmd
    }
}

tasks.register('updateDartDependencies') {
    doLast {
        println "Pre-cleaning Dart temp dir '$dartDownloadTemp' and target dir '$dartDownload'"
        delete "$dartDownloadTemp"
        delete "$dartDownload"
        // Fetch the Dart SDK from "custom ivy repo" set up above
        println "Unzipping Dart SDK to temp dir '$dartDownloadTemp'"
        copy {
            from zipTree(configurations.dartSdk.asPath)
            into "$dartDownloadTemp"
        }

        // Move it into place - avoids problem if IntelliJ is set up to use the Dart SDK here ("Text file busy")
        // Note: If on Windows, you'll probably have to find another SDK location for IntelliJ, as it locks the files.
        println "Renaming Dart SDK download to '$dartDownload'"
        dartDownloadTemp.renameTo(dartDownload)

        // Update dart dependencies by executing 'pub get'
        println "Executing 'dart pub get' to resolve and fetch dependencies."
        dartExec 'pub', 'get'
        dartExec '--version' // Just to show which dart version we are using.

        println "All good, cleaning Dart temp dir '$dartDownloadTemp'"
        delete "$dartDownloadTemp"
    }
}

tasks.register('dartOutdated') {
    dependsOn updateDartDependencies
    doLast {
        dartExec 'pub', 'outdated'
    }
}

tasks.register('dartUpgradeUpdate') {
    dependsOn updateDartDependencies
    doLast {
        dartExec 'pub', 'upgrade', '--major-versions'
    }
}

tasks.register('dartVersion') {
    dependsOn updateDartDependencies
    doLast {
        dartExec '--version'
    }
}
tasks.register('versions') { dependsOn dartVersion }

// Small helper to register a Dart test task with platform and compiler variants.
def registerDartTestTask = { String name, String platform, String compiler ->
    tasks.register(name) {
        dependsOn 'updateDartDependencies', ':startMatsSocketTestServer'
        if (platform == 'node') {
            dependsOn 'nodeBinDir' // Need to have figured out where node is.
        }

        def chromePath = providers.gradleProperty('chromePath')

        doLast {
            dartExec {
                // :: Setting environment for test run
                environment("MATS_SOCKET_URLS", rootProject.wsUrls.join(","))
                // Checking which log level is enabled to pass on to the tests, so that they log if needed.
                if (logger.isEnabled(LogLevel.DEBUG)) {
                    environment("LOG_LEVEL", "DEBUG")
                } else if (logger.isEnabled(LogLevel.INFO)) {
                    environment("LOG_LEVEL", "INFO")
                } else {
                    environment("LOG_LEVEL", "SEVERE")
                }
                def testFiles = file("$projectDir/test")
                        .listFiles().findAll { it.name.endsWith(".dart") }.collect { "test/${it.name}" }
                args = ['test', '-p', platform, '-c', compiler, '--reporter=expanded', '-j', '1'] + testFiles
                if (platform == 'chrome' && chromePath.isPresent()) {
                    environment("CHROME_EXECUTABLE", chromePath.get())
                }
                if (platform == 'node') {
                    println "NODE_BIN_DIR (from project.ext): ${project.ext.NODE_BIN_DIR}"
                    environment 'PATH', "${project.ext.NODE_BIN_DIR}${File.pathSeparator}$dartSdkPath/bin${File.pathSeparator}${System.getenv('PATH')}"
                }
                println "Executing 'dart ${args.join(" ")}' to run tests."
            }
        }
    }
}

// Define the various test tasks with their platform/compiler variants.
registerDartTestTask('testWebJs', 'chrome', 'dart2js')
registerDartTestTask('testWebWasm', 'chrome', 'dart2wasm')
registerDartTestTask('testVmExe', 'vm', 'exe')
registerDartTestTask('testVmSource', 'vm', 'source')
registerDartTestTask('testVmKernel', 'vm', 'kernel')
registerDartTestTask('testNodeJs', 'node', 'dart2js')
registerDartTestTask('testNodeWasm', 'node', 'dart2wasm')

// Subsets
tasks.register('testWeb') { dependsOn 'testWebJs', 'testWebWasm' }
tasks.register('testVm') { dependsOn 'testVmExe', 'testVmSource', 'testVmKernel' }
tasks.register('testNode') { dependsOn 'testNodeJs', 'testNodeWasm'}

// All tests
tasks.register('testAll') { dependsOn 'testWeb', 'testVm', 'testNode' }

// Make 'test' be both VM and Node.
// ?:Are we running on Windows? (GHA)
if (currentOs.isWindows()) {
    // -> Yes, Windows, special handling. Avoid the testNodeWasm, as it fails due to bad path handling,
    println "Windows OS detected ('${currentOs}'), thus avoiding task 'testNodeWasm' due to bad path handling," +
            " where e.g. '/runner' becomes '<linefeed>unner', and fails."
    tasks.register('test') { dependsOn 'testVm', 'testNodeJs' }
}
else {
    // -> No, not Windows, so include all testVm and testNode tasks.
    println "Non-Windows OS detected ('${currentOs}'), so including all 'testVM' and 'testNode' tasks."
    tasks.register('test') { dependsOn 'testVm', 'testNodeJs', 'testNodeWasm' }
}

// We need to ensure that dart tests are run before stopping the test MatsSocketServer.
rootProject.stopMatsSocketTestServer.mustRunAfter(testWebJs, testWebWasm, testVmExe, testVmSource, testVmKernel,
        testNodeJs, testNodeWasm, test, testAll)

// 'dart publish --dry-run'
tasks.register('publishDryRun') {
    dependsOn updateDartDependencies
    doLast {
        dartExec 'pub', 'publish', '--dry-run'
    }
}

// 'dart publish --force'
tasks.register('publish') {
    dependsOn updateDartDependencies
    doLast {
        dartExec 'pub', 'publish', '--force'
    }
}

// Package up the Dart library
tasks.register('archiveLib', Zip) {
    from "$projectDir/lib"
    into "mats_socket-${project.version}-dart"
    archiveFileName = "mats_socket-${project.version}-dart.zip"
    destinationDirectory.set(layout.buildDirectory.dir("dist"))
    doLast {
        println("##### Dart Client zip: " + destinationDirectory.get().asFile + "/" + archiveFileName)
    }
}

tasks.register('clean', Delete) {
    delete layout.buildDirectory
}

tasks.register('distclean', Delete) {
    dependsOn clean, distcleanNode
    delete "$dartDownload"
    delete "$dartDownloadTemp"
    delete "$projectDir/.dart_tool"
}

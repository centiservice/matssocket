<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8"/>
<head>
    <title>MatsSocket concurrent requests</title>
    <style>
        #request_table {
            border: 1px solid black;
            border-collapse: collapse;
            font-size: 8px;
            table-layout: fixed;
            width: 2000px;
        }

        td {
            overflow: hidden;
        }

    </style>
</head>
<body>
<h1 id="title_heading">Many requests</h1>
Sends off a couple of thousand requests in a for-loop, which then updates the respective cell when the Promise resolves.<br>
The result is a (semi-)parallel execution of all these calls, which is visualized in the table below.<br>
Each Request uses its own separate callback (i.e. not targeting a common MatsSocket "Endpoint") that completes the
round-trip by updating
the specific cell with its timing information.<br>

<p><b>If you just started the <code>MatsSocketTestServer</code>, then let it run some 20 times to warm up!</b><br></p>

<p><b>For some reason, this works fastest in a <i>Chrome Private Window!</i></b> .. and server -Dloglevel=OFF! (-P for
gradle)<br>
<i>You can open e.g. 6 private windows and let them hammer simultaneously. Set 'delay' to e.g. 10 then.
"Fastest" is meaningless then. Saturate your CPU!<br></i></p>

<p>MatsSocket Ping Endpoint: <code><b><span id="endpoint"></span></b></code>
- <i>(change with ?mode=[<a href="?mode=mats">mats</a>|<b><a href="?mode=matsSocket">matsSocket</a></b>]
- matsSocket resolves directly, while mats forwards to a Mats3 Endpoint)</i><br>

Delay: <code><b><span id="delay"></span></b></code>
- <i>(change with ?delay={ms})</i><br>

Cell update: <code><b><span id="muted"></span></b></code>
- <i>(change with ?muted - <a href="?mode=mats&muted">mats&muted</a> | <a href="?mode=matsSocket&muted">matsSocket&muted</a>)</i></p>

<span id="statistics">Here will be statistics...<br>..</span>

<script type="module">
    import * as mats from './mats/client/lib/MatsSocket.js';

    function tableCreate(rows, columns) {
        let body = document.body;
        let table = document.createElement('table');
        table.id = "request_table";

        for (let i = 0; i < rows; i++) {
            let tr = table.insertRow();
            for (let j = 0; j < columns; j++) {
                let cellNum = j * rows + i;
                let td = tr.insertCell();
                td.id = "request_" + cellNum;
                td.innerHTML = "-";
            }
        }
        body.appendChild(table);
    }

    let rows = 80;
    let columns = 50;

    tableCreate(rows, columns);

    const urlParams = new URLSearchParams(window.location.search);
    const mode = urlParams.get('mode') || 'matsSocket';
    const useMatsPing = mode === 'mats'; // Default to matsSocketPing
    // NOTICE: We do NOT use MatsSocket.matsSocketPing, due to special handling of 'delay' param for that.
    // Read mode in the setup-code of Test.matsSocketPing.
    const endpoint = useMatsPing ? 'MatsSocket.matsPing' : 'Test.matsSocketPing';
    const expectedFactor = useMatsPing ? Math.PI : Math.E;
    document.getElementById("endpoint").innerText = endpoint;

    const delay = urlParams.get('delay') || '500';
    document.getElementById("delay").innerText = delay;

    const muted = urlParams.get('muted') !== null;
    document.getElementById("muted").innerText = muted ? "Muted - NOT showing individual requests" : "Not muted - showing individual requests";

    let matsSocket = new mats.MatsSocket("TestApp", "1.2.3",
        ["ws://localhost:8080/matssocket", "ws://localhost:8081/matssocket"]);
    matsSocket.setCurrentAuthorization("DummyAuth:standard:-1", -1);

    function ms(millis) {
        return Math.round(millis * 100) / 100;
    }

    let fastest = -1;
    let fastestReport;

    function doRun() {
        let totalNumMessages = rows * columns;

        document.getElementById("title_heading").innerText = totalNumMessages + " concurrent requests";

        let receivedCount = 0; // Number of received messages
        let sumRTTMillis = 0; // Sum of millis per message, to get average.
        let lowestRTTMillis = 1000000000;
        let highestRTTMillis = -1;

        let startMillis = performance.now();
        let forLoopMillis;

        // Fire off a request for each of the Table's cells.
        for (let cellNum = 0; cellNum < totalNumMessages; cellNum++) {
            let requestId = "request_" + cellNum;
            let requestCell = document.getElementById(requestId);
            if (!muted) {
                requestCell.innerHTML = "Req " + cellNum;
            }
            let traceId = cellNum + ":" + matsSocket.randomId(3);

            // Fire off the MatsSocket request
            matsSocket.request(endpoint, traceId,
                // The Request DTO
                {
                    string: "Request:" + requestId,
                    number: Math.E * cellNum
                })
                .then(function (event) {
                    // Assert that it has been through either both MatsSocket and Mats, or just MatsSocket.
                    if (event.data.number !== Math.E * cellNum * expectedFactor) {
                        throw new Error("Wrong 'number' for TraceId [" + traceId + "].");
                    }
                    // Setting data in Table's cell
                    let timeTakenMs = event.roundTripMillis;
                    sumRTTMillis += timeTakenMs;
                    if (timeTakenMs < lowestRTTMillis) {
                        lowestRTTMillis = timeTakenMs;
                    }
                    if (timeTakenMs > highestRTTMillis) {
                        highestRTTMillis = timeTakenMs;
                    }
                    if (!muted) {
                        requestCell.innerHTML = "<b>" + ms(timeTakenMs) + "</b>";
                    }
                    receivedCount++;

                    // ?: Is this the last reply coming in?
                    if (receivedCount === totalNumMessages) {
                        // -> Yes, last reply - so update the stats message at top.
                        let totalMillis = performance.now() - startMillis;
                        let averagePerMessage = sumRTTMillis / totalNumMessages;
                        let throughputPerSecond = (totalNumMessages / totalMillis) * 1000;
                        let report = "Time to send all: <b>" + ms(forLoopMillis) + "ms</b>,"
                            + " Total time for all requests+replies: <b>" + ms(totalMillis)
                            + " ms</b>, average RTT per message: <b>" + ms(averagePerMessage)
                            + "</b> (low: " + ms(lowestRTTMillis) + " ms, high: " + ms(highestRTTMillis) + " ms)"
                            + " ms</b>, throughput: <b>" + ms(throughputPerSecond) + " msg/sec</b>";
                        if (totalMillis < fastest || fastestReport === undefined) {
                            fastest = totalMillis;
                            fastestReport = report;
                        }
                        document.getElementById("statistics").innerHTML =
                            "<b>" + totalNumMessages + "</b> requests: " + report +
                            "<br><i style='padding-left: 2.4em;'>Fastest: " + fastestReport + "</i>";

                        setTimeout(() => {
                            doRun();
                        }, delay);
                    }
                });
            if (cellNum % 500 === 0) {
                matsSocket.flush();
            }
        }
        matsSocket.flush();
        forLoopMillis = performance.now() - startMillis;
    }

    setTimeout(() => {
        doRun();
    }, 1000);

</script>


</body>
</html>
<!doctype html>
<html>
<meta charset="UTF-8"/>
<head><title>CDN using UMD bundle</title></head>
<body>
<h1>CDN using UMD bundle</h1>

NOTE! You must open the browser's DevTool Console to see what happens in the console log.

<ul>
    <li><span id="sendReceivedOnServer">.. send pending ..</span></li>
    <li><span id="requestReplied">.. request pending ..</span></li>
    <li><span id="terminatorReplyToA">.. requestReplyTo A pending ..</span></li>
    <li><span id="terminatorReplyToB">.. requestReplyTo B pending ..</span></li>
    <li><span id="terminatorReplyToC">.. requestReplyTo C pending ..</span></li>
</ul>

<script src="https://cdn.jsdelivr.net/npm/matssocket@1.0.0-rc1-2025-10-04/dist/MatsSocket.umd.min.js"
        integrity="sha384-ViD2k59N3y1xE1T/TPyjxXS17F/t2RN240XPhODF/S9b3wB/kZ+H1RLptGFjgEKF"
        crossorigin="anonymous"></script>

<script>
    let matsSocket = new matssocket.MatsSocket("TestApp", "1.2.3",
        ['ws://localhost:8080/matssocket', 'ws://localhost:8081/matssocket']);

    // ===== Configure the MatsSocket, Listeners, and Terminator

    matsSocket.preconnectoperation = true;
    matsSocket.logging = true;
    matsSocket.debug = matssocket.DebugOption.TIMESTAMPS | matssocket.DebugOption.NODES;

    matsSocket.setAuthorizationExpiredCallback(function (event) {
        console.log("Got AuthorizationExpiredCallback from MatsSocket, regenerating Authorization header.");
        console.log(event);

        // Emulate that it takes some time to get new auth.
        setTimeout(function () {
            let now = Date.now();
            let expiry = now + 20000;
            // Special userId 'enableAllDebugOptions' that the dummy auth grants all debug options.
            matsSocket.setCurrentAuthorization("DummyAuth:enableAllDebugOptions:" + expiry, expiry, 10000);
        }, 100 + (100 * Math.random()));
    });

    // Create a Terminator for the requestReplyTo Requests.
    matsSocket.terminator("ClientSide.testEndpoint", function (messageEvent) {
        let millis = Date.now() - messageEvent.clientRequestTimestamp;
        console.log("Got message! correlationInformation:" + messageEvent.correlationInformation
            + ", our timing: " + millis + "ms"
            + ", roundTripMillis: " + messageEvent.roundTripMillis + "ms"
            + ", clientMessageReceivedNodename: " + messageEvent.debug.clientMessageReceivedNodename
            + ", matsMessageReplyReceivedNodename: " + messageEvent.debug.matsMessageReplyReceivedNodename
            + ", messageSentToClientNodename:" + messageEvent.debug.messageSentToClientNodename);
        // Update correct span based on correlationInformation starting with A, B or C
        let span = document.getElementById("terminatorReplyTo" + messageEvent.correlationInformation.charAt(0));
        if (span) {
            span.innerHTML = "Got message! correlationInformation:" + messageEvent.correlationInformation
                + ", our timing: " + millis + "ms"
                + ", roundTripMillis: " + messageEvent.roundTripMillis + "ms"
                + ", data: " + JSON.stringify(messageEvent.data);
        }
    });

    // ===== Perform some operations.

    matsSocket.send("Test.single", "SEND_" + matsSocket.randomId(6), {string: "The String", number: Math.PI});

    matsSocket.send("Test.single", "SEND-with-Promise_" + matsSocket.randomId(6), {string: "The String", number: Math.PI})
        .then(function (receivedEvent) {
            console.log("SEND-with-Promise resolved! (message received on server) Took " + receivedEvent.roundTripMillis + "ms: " + JSON.stringify(receivedEvent));
            // Update the span
            document.getElementById("sendReceivedOnServer").innerHTML = "SEND-with-Promise resolved! (message received on server) Took " + receivedEvent.roundTripMillis + "ms: " + JSON.stringify(receivedEvent);
        });

    matsSocket.request("Test.single", "REQUEST-with-Promise_" + matsSocket.randomId(6), {
        string: "Request String",
        number: Math.E
    }).then(function (messageEvent) {
        console.log("REQUEST-with-Promise resolved! (I.e. REPLY from Mats Endpoint) Took "
            + messageEvent.roundTripMillis + "ms: " + JSON.stringify(messageEvent));
        // Update the span
        document.getElementById("requestReplied").innerHTML = "REQUEST-with-Promise resolved! (I.e. REPLY from Mats Endpoint) Took " + messageEvent.roundTripMillis + "ms: " + JSON.stringify(messageEvent);
    });

    matsSocket.flush();

    matsSocket.requestReplyTo("Test.single", "REQUEST-autoPipeline-with-ReplyTo_1_" + matsSocket.randomId(6),
        {string: "Messge 1", number: 100.001, requestTimestamp: Date.now()},
        "ClientSide.testEndpoint", "A_pipeline_1_" + matsSocket.randomId(10));
    matsSocket.requestReplyTo("Test.single", "REQUEST-autoPipeline-with-ReplyTo_2_" + matsSocket.randomId(6),
        {string: "Message 2", number: 200.002, requestTimestamp: Date.now()},
        "ClientSide.testEndpoint", "B_pipeline_2_" + matsSocket.randomId(10));
    matsSocket.requestReplyTo("Test.single", "REQUEST-autoPipeline-with-ReplyTo_3_" + matsSocket.randomId(6),
        {string: "Message 3", number: 300.003, requestTimestamp: Date.now()},
        "ClientSide.testEndpoint", "C_pipeline_3_" + matsSocket.randomId(10));

    matsSocket.flush();

    setTimeout(function () {
        console.log("Closing MatsSocket");
        matsSocket.close("Test done");
    }, 5000);

</script>

</body>
</html>
